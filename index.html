<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>MCQ Quiz • CSV/JSON (PWA)</title>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0f1218">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
/* --- MOBILE LAYOUT FIXES --- */

/* Use dynamic viewport height so iOS Safari accounts for URL bars */
html, body { height: 100%; }
body{
  /* switch from CSS grid to flex so main can truly flex/scroll */
  display: flex;
  flex-direction: column;
  min-height: 100dvh; /* dynamic viewport height */
  overflow: hidden;   /* prevent double scrollbars on iOS */
}

/* Let main fill remaining space and be scrollable */
main{
  flex: 1 1 auto;
  min-height: 0;       /* important for flex children to shrink correctly */
  overflow-y: auto;    /* page scroll lives here */
  -webkit-overflow-scrolling: touch;
}

/* Stage stays responsive but won’t force page wider than screen */
.stage{ width: min(960px, 100%); }

/* On phones: hide the header entirely to save space */
@media (max-width: 640px){
  header{ display: none; }
  /* When header is gone, body is just main + footer */
}

/* Make the card content comfortable on small screens */
@media (max-width: 640px){
  /* Let the card height be driven by content + viewport */
  .card{ min-height: 0; height: auto; }

  /* The faces already scroll internally; make sure they can */
  .face{ overflow: auto; -webkit-overflow-scrolling: touch; }

  /* Keep the action buttons visible as you read the question */
  .controls{
    position: sticky;
    bottom: 0;
    z-index: 2;
    /* subtle backdrop so buttons pop over text */
    background: linear-gradient(to top, rgba(23,27,34,0.96), rgba(23,27,34,0.4));
    padding-top: 8px;
    margin-top: 10px;
    backdrop-filter: blur(6px);
  }
}

/* If your footer gets in the way on phones, make it slimmer */
@media (max-width: 640px){
  footer{ font-size: 12px; padding: 8px 12px; }
}
  </style>
</head><body>
<header style="">
  <h1>MCQ Quiz • CSV/JSON (PWA)</h1>
  <div class="sub">Tap an option → Submit → flip for the answer. Optimized for iPhone, offline-ready.</div>
  
 <div class="toolbar">
    <div class="row">
      <select id="chapterFilter" title="Filter by chapter" disabled>
        <option value="__ALL__">All chapters</option>
      </select>
      <button id="applyFilter" class="primary">Apply Filter</button>
      <button id="reshuffle" class="ghost">Re-shuffle</button>
    </div>
    <div class="row">
      <input id="filePicker" type="file" accept=".json,.csv" />
      <button id="loadDefault" class="accent">Load quiz-ch3.json</button>
      <button id="resetSession" class="danger">Reset Session</button>
    </div>
  </div>
</header>

<main>
  <div class="stage">
    <div class="meta">
      <span id="metaPool" class="badge">Pool: 0</span>
      <span id="metaViewed" class="badge">Viewed: 0</span>
      <span id="metaChapter" class="badge">Chapter: All</span>
      <span id="metaScore" class="badge">Score: 0</span>
      <span id="metaProgress" class="badge">Progress: 0 / 0</span>
      <span class="badge">Submit to flip</span>
    </div>

    <div class="card" id="card">
      <div class="card-inner" id="cardInner">
        <div class="face front">
          <h2 id="questionText"></h2>
          <div id="options" class="options"></div>
          <div class="controls">
            <button id="prevBtn">← Previous</button>
            <button id="submitBtn" class="primary">Submit</button>
            <button id="nextBtn" class="primary">Next →</button>
            <button id="skipBtn" class="ghost">Skip</button>
          </div>
          <div class="small" id="helper"></div>
        </div>
        <div class="face back">
          <h3 id="answerHeader"></h3>
          <div class="expl" id="explanationText"></div>
          <div class="controls">
            <button id="flipBackBtn">← Back</button>
            <button id="nextFromBackBtn" class="primary">Next →</button>
            <button id="reshuffle2" class="ghost">Re-shuffle</button>
            <button id="reset2" class="danger">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <div id="emptyState" class="empty hidden">
      <p>No questions in this pool/filter. Try <strong>Re-shuffle</strong> or load data.</p>
    </div>
  </div>
</main>

<footer>MCQ Quiz PWA • Offline • iPhone-friendly layout</footer>

<script>
(function(){
  const el = id => document.getElementById(id);
  const cardInner = el('cardInner');
  const questionText = el('questionText');
  const optionsEl = el('options');
  const answerHeader = el('answerHeader');
  const explanationText = el('explanationText');
  const helper = el('helper');

  const meta = {
    pool: el('metaPool'), viewed: el('metaViewed'), chapter: el('metaChapter'),
    progress: el('metaProgress'), score: el('metaScore')
  };
  const chapterFilter = el('chapterFilter');

  let all = [];         // full dataset
  let pool = [];        // filtered/shuffled dataset
  let idx = 0;          // current index in pool
  let viewed = new Set();
  let score = 0;        // correct count
  let answeredThis = false;
  let userChoice = null;

  function normalizeAnswer(a, options){
    if(!a) return '';
    const s = String(a).trim();
    const map = {A:0,B:1,C:2,D:3};
    if (s.length===1 && map[s.toUpperCase()]!=null) return s.toUpperCase();
    // try to match by text
    const i = options.findIndex(opt => opt && opt.trim().toLowerCase() === s.toLowerCase());
    if (i>=0) return Object.keys(map)[i];
    return s; // leave as-is
  }

  function hasChapter(){
    return all.some(q => q.chapter && String(q.chapter).trim() !== '');
  }

  function updateChapterFilter(){
    const chapters = Array.from(new Set(all.map(q => (q.chapter||'').trim()).filter(Boolean))).sort();
    chapterFilter.innerHTML = '<option value="__ALL__">All chapters</option>' +
      chapters.map(ch => `<option value="${ch}">${ch}</option>`).join('');
    chapterFilter.disabled = chapters.length === 0;
  }

  function applyFilter(){
    const sel = chapterFilter.value;
    pool = all.filter(q => sel==='__ALL__' ? true : String(q.chapter||'').trim()===sel);
    reshuffle(false);
    meta.chapter.textContent = 'Chapter: ' + (sel==='__ALL__'?'All':sel);
  }

  function reshuffle(resetViewed=true){
    pool = pool.sort(()=>Math.random()-0.5);
    idx = 0;
    if (resetViewed) viewed.clear();
    score = 0;
    cardInner.classList.remove('flipped');
    render();
  }

  function render(){
    // handle empty
    el('emptyState').classList.toggle('hidden', pool.length>0);
    el('card').classList.toggle('hidden', pool.length===0);
    if (pool.length===0) return;

    const q = pool[idx];
    questionText.textContent = q.question || '(No question)';
    optionsEl.innerHTML = '';
    const labels = ['A','B','C','D'];
    (q.options || []).slice(0,4).forEach((text, i) => {
      const lab = labels[i];
      const row = document.createElement('label');
      row.className = 'option';
      row.innerHTML = `
        <input type="radio" name="opt" value="${lab}">
        <div><strong>${lab}.</strong> ${text || ''}</div>
      `;
      optionsEl.appendChild(row);
    });
    answeredThis = false;
    userChoice = null;
    helper.textContent = 'Select one option, then press Submit.';
    updateMeta();
  }

  function flipToBack(correct, picked, rightLetter, rightText, expl){
    const msg = correct
      ? `✅ Correct — ${rightLetter}. ${rightText}`
      : `❌ Incorrect — You chose ${picked}. Correct is ${rightLetter}. ${rightText}`;
    answerHeader.className = correct ? 'correct' : 'incorrect';
    answerHeader.textContent = msg;
    explanationText.textContent = expl || '';
    cardInner.classList.add('flipped');
  }

  function flipBack(){
    cardInner.classList.remove('flipped');
  }

  function currentQ(){
    return pool[idx];
  }

  function submit(){
    if (answeredThis) { return; }
    const q = currentQ();
    const picked = document.querySelector('input[name="opt"]:checked');
    if (!picked){
      helper.textContent = 'Pick an option before submitting.';
      return;
    }
    userChoice = picked.value; // A/B/C/D
    const labels = ['A','B','C','D'];
    const right = normalizeAnswer(q.answer, q.options || []);
    const rightIdx = labels.indexOf(right);
    const rightText = (q.options||[])[rightIdx] || '';
    const correct = userChoice === right;
    if (correct) score++;
    answeredThis = true;
    viewed.add(idx);
    flipToBack(correct, userChoice, right || '—', rightText, q.explanation || '');
    updateMeta();
  }

  function next(){
    if (pool.length===0) return;
    idx = (idx + 1) % pool.length;
    cardInner.classList.remove('flipped');
    render();
  }

  function prev(){
    if (pool.length===0) return;
    idx = (idx - 1 + pool.length) % pool.length;
    cardInner.classList.remove('flipped');
    render();
  }

  function skip(){
    next();
  }

  function updateMeta(){
    meta.pool.textContent = 'Pool: ' + pool.length;
    meta.viewed.textContent = 'Viewed: ' + viewed.size;
    meta.progress.textContent = `Progress: ${idx+1} / ${pool.length}`;
    meta.score.textContent = `Score: ${score}`;
  }

  async function parseCSV(text){
    // very light CSV (expects headers: Chapter,Question,Option A,B,C,D,Correct Answer,Explanation)
    const lines = text.split(/\r?\n/).filter(l=>l.trim()!=='');
    if (!lines.length) return [];
    const headers = lines[0].split(',').map(h=>h.trim().replace(/^\uFEFF/,''));
    const gi = name => headers.findIndex(h => h.toLowerCase()===name.toLowerCase());
    const col = {
      chapter: gi('Chapter'),
      question: gi('Question'),
      oa: gi('Option A'),
      ob: gi('Option B'),
      oc: gi('Option C'),
      od: gi('Option D'),
      ans: gi('Correct Answer'),
      expl: gi('Explanation')
    };
    return lines.slice(1).map(line=>{
      // naive split; handles quotes if simple, but for complex CSV use JSON instead
      const cells = line.match(/("([^"]|"")*"|[^,]*)/g).filter((_,i)=>i%2===0).map(s=>s.replace(/^"(.*)"$/,'$1').replace(/""/g,'"'));
      const pick = i => (i>=0 && i<cells.length) ? cells[i] : '';
      return {
        chapter: pick(col.chapter) || '',
        question: pick(col.question) || '',
        options: [pick(col.oa), pick(col.ob), pick(col.oc), pick(col.od)],
        answer: pick(col.ans) || '',
        explanation: pick(col.expl) || ''
      };
    }).filter(r=>r.question);
  }

  function setData(rows){
    all = rows.map(r=>({
      chapter: r.chapter || '',
      question: r.question || '',
      options: (r.options || []).slice(0,4),
      answer: r.answer || '',
      explanation: r.explanation || ''
    })).filter(r=>r.question && r.options.some(Boolean));
    updateChapterFilter();
    // default filter = All
    pool = all.slice();
    reshuffle(true);
  }

  // Load default file (must be in same folder)
  async function loadDefault(){
    try{
      const res = await fetch('./quiz-ch3.json?v=' + Date.now());
      if (!res.ok) throw new Error('Not found');
      const json = await res.json();
      setData(json);
    }catch(e){
      helper.textContent = 'Could not fetch quiz-ch3.json. Use Upload to load JSON/CSV.';
    }
  }

  // Handlers
  el('submitBtn').addEventListener('click', submit);
  el('nextBtn').addEventListener('click', next);
  el('prevBtn').addEventListener('click', prev);
  el('skipBtn').addEventListener('click', skip);
  el('flipBackBtn').addEventListener('click', flipBack);
  el('nextFromBackBtn').addEventListener('click', next);
  el('reshuffle').addEventListener('click', ()=>reshuffle(true));
  el('reshuffle2').addEventListener('click', ()=>reshuffle(true));
  el('resetSession').addEventListener('click', ()=>{ viewed.clear(); score=0; idx=0; render(); });
  el('reset2').addEventListener('click', ()=>{ viewed.clear(); score=0; idx=0; flipBack(); render(); });
  el('applyFilter').addEventListener('click', applyFilter);
  el('loadDefault').addEventListener('click', loadDefault);

  el('filePicker').addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if (!file) return;
    const text = await file.text();
    if (file.name.toLowerCase().endsWith('.json')){
      try { setData(JSON.parse(text)); }
      catch { helper.textContent = 'Invalid JSON.'; }
    } else {
      const rows = await parseCSV(text);
      setData(rows);
    }
  });

  // init (tries to fetch default if present)
  loadDefault();

  // PWA
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./service-worker.js').catch(()=>{});
  }
})();
</script>
</body></html>
